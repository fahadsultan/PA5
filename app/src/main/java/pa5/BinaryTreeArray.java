/*
 * This source file was generated by the Gradle 'init' task
 */
package pa5;


/**
 *  Interface for a binary tree implemented using an array
*   The tree must adhere to the properties of a complete binary tree: 
*      A complete binary tree is a binary tree in which every level,
*      The tree is completely filled on all levels except possibly 
*      for the lowest level, which is filled from left to right.
 */
interface ArrayBasedBinaryTree {

    /**
     * Inserts an element into the tree. 
     * Assume `element` is always a positive integer
     */
    void insert(int element);

    /**
     * Returns the tree in level order
     */
    String levelOrder();

    /**
     * Returns the tree in in-order
     */
    String inOrder();

    /**
     * Returns the tree in pre-order
     */
    String preOrder();

    /**
     * Print the tree in post-order
     */
    String postOrder();

    /**
     * Return the length of the longest path in the tree
     */
    int longestPath();

    /**
     * Delete an element from the tree
     * Ensure that the tree remains a complete binary tree
     */
    void delete(int element);
}

// Array based implementation of a simple binary tree
public class BinaryTreeArray implements ArrayBasedBinaryTree{
    
    private int[] data;

    public BinaryTreeArray(int size){
        this.data = new int[size];
    }

    public void insert(int element){
        for (int i = 0; i < this.data.length; i++){
            if (this.data[i] == 0){
                this.data[i] = element;
                break;
            }
        }
    }

    public String levelOrder(){
        String result = "";
        for (int i = 0; i < this.data.length; i++){
            if (this.data[i] != 0){
                result += this.data[i] + " ";
            }
        }
        return result;
    }

    public String inOrder(){
        return this.printInOrderHelper(0);
    }

    private String printInOrderHelper(int i){
        if (i >= this.data.length || this.data[i] == 0){
            return "";
        }
        return this.printInOrderHelper(2*i+1) + this.data[i] + " " + this.printInOrderHelper(2*i+2);
    }

    public String preOrder(){
        return this.preOrderHelper(0);
    }

    private String preOrderHelper(int i){
        if (i >= this.data.length || this.data[i] == 0){
            return "";
        }
        return this.data[i] + " " + this.preOrderHelper(2*i+1) + this.preOrderHelper(2*i+2);
    }

    public String postOrder(){
        return this.postOrderHelper(0);
    }

    private String postOrderHelper(int i){
        if (i >= this.data.length || this.data[i] == 0){
            return "";
        }
        return this.postOrderHelper(2*i+1) + this.postOrderHelper(2*i+2) + this.data[i] + " ";
    }

    public int longestPath(){
        return this.longestPathHelper(0, 0);
    }

    private int longestPathHelper(int i, int count){
        if (i >= this.data.length || this.data[i] == 0){
            return count-1;
        }
        int left = this.longestPathHelper(2*i+1, count+1);
        int right = this.longestPathHelper(2*i+2, count+1);
        if (left > right){
            return left;
        }
        else{
            return right;
        }
    }

    public void delete(int element){
        for (int i = 0; i < this.data.length; i++){
            if (this.data[i] == element){
                this.data[i] = 0;
                break;
            }
        }

        for (int i = 0; i < this.data.length; i++){
            if (this.data[i] == 0){
                int j = i+1;
                while (j < this.data.length && this.data[j] != 0){
                    this.data[j-1] = this.data[j];
                    this.data[j] = 0;
                    j++;
                }
            }
        }
    }

    public static void main(String[] args){
        
        BinaryTreeArray tree = new BinaryTreeArray(10);

        tree.insert(1);
        tree.insert(2);
        tree.insert(3);
        tree.insert(4);

        System.out.println(tree.levelOrder());  // 1 2 3 4
        System.out.println(tree.preOrder());    // 1 2 4 3
        System.out.println(tree.inOrder());     // 4 2 1 3
        System.out.println(tree.postOrder());   // 4 2 3 1
        System.out.println(tree.longestPath()); // 2

        tree.insert(5);
        tree.insert(6);
        tree.insert(7);
        tree.insert(8);
        tree.insert(9);
        tree.insert(10);

        System.out.println("Level order traversal: ");
        System.out.println(tree.levelOrder()); // 1 2 3 4 5 6 7 8 9 10

        System.out.println("\nPre order traversal: ");
        System.out.println(tree.preOrder()); // 1 2 4 8 9 5 10 3 6 7

        System.out.println("\nIn order traversal: ");
        System.out.println(tree.inOrder()); // 8 4 9 2 10 5 1 6 3 7

        System.out.println("\nPost order traversal: ");
        System.out.println(tree.postOrder()); // 8 9 4 10 5 2 6 7 3 1

        System.out.println("\nLongest path: ");
        System.out.println(tree.longestPath()); // 3

        try {
            tree.insert(11);
        } catch (ArrayIndexOutOfBoundsException e){
            System.out.println("Cannot insert element. Tree is full.");
        }

        tree.delete(1);

        System.out.println("Level order traversal: "+tree.levelOrder()); // 2 4 3 8 9 5 10 6 7
        System.out.println("Pre order traversal: "+tree.preOrder());     // 2 4 8 9 5 10 3 6 7
        System.out.println("In order traversal: "+tree.inOrder());       // 8 4 9 2 10 5 6 3 7
        System.out.println("Post order traversal: "+tree.postOrder());   // 8 9 4 10 5 2 6 7 3

        System.out.println("Longest path: "+tree.longestPath()); // 3

        tree.insert(1);

        System.out.println("Level order traversal: " + tree.levelOrder()); // 2 4 3 8 9 5 10 6 7 1 _or_  1 2 4 3 8 9 5 10 6 7

    }
}
